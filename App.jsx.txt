import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, updateDoc, arrayUnion, serverTimestamp } from 'firebase/firestore';

// --- CONFIGURATION DE BASE ET PROFILES CHIENS (R√®gles M√©tier) ---

// Les r√®gles de compatibilit√© du chien (√âtiquette -> Couleur + Compatibilit√©)
const DOG_PROFILES = {
  // üü£ 1 ‚Äî Chiot
  Chiot: {
    color: 'purple', emoji: 'üü£', compatibleWith: ['Polyvalent', 'Chiot', 'Harceleur'],
  },
  // üü° 2 ‚Äî Polyvalent (Safe)
  Polyvalent: {
    color: 'yellow', emoji: 'üü°', compatibleWith: ['Chiot', 'Polyvalent', 'Agressif', 'Peureux', 'Harceleur'],
  },
  // üî¥ 3 ‚Äî Agressif
  Agressif: {
    color: 'red', emoji: 'üî¥', compatibleWith: ['Polyvalent'],
  },
  // üîµ 4 ‚Äî Peureux
  Peureux: {
    color: 'blue', emoji: 'üîµ', compatibleWith: ['Polyvalent', 'Chiot'],
  },
  // üü† 5 ‚Äî Harceleur
  Harceleur: {
    color: 'orange', emoji: 'üü†', compatibleWith: ['Polyvalent', 'Harceleur', 'Chiot'],
  },
};

// Jours et cr√©neaux pour l'interface de disponibilit√©
const DAYS = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
const SLOTS = ['Matin', 'D√©but AP', 'Fin AP', 'Soir√©e'];

// Configuration Firebase
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

// Initialisation des services Firebase
let app, db, auth;
if (Object.keys(firebaseConfig).length > 0) {
  app = initializeApp(firebaseConfig);
  db = getFirestore(app);
  auth = getAuth(app);
}

// Fonction utilitaire pour le chemin des collections publiques (pour le partage des matchs)
const getPublicCollectionRef = (collectionName) => {
  return collection(db, `/artifacts/${appId}/public/data/${collectionName}`);
};


// Composant principal de l'application
export default function App() {
  const [activeTab, setActiveTab] = useState('profil');
  const [authState, setAuthState] = useState({ userId: null, isLoading: true, db: null, auth: null });
  const [userName, setUserName] = useState('');
  const [userCity, setUserCity] = useState('');
  const [isEditingProfile, setIsEditingProfile] = useState(false);
  const [userProfile, setUserProfile] = useState(null); // Contient toutes les donn√©es du profil
  const [availabilities, setAvailabilities] = useState({});
  const [matches, setMatches] = useState([]);
  const [statusMessage, setStatusMessage] = useState({ type: '', text: '' }); // Pour afficher les messages (succ√®s/erreur)

  // 1. Initialisation de Firebase et Authentification
  useEffect(() => {
    if (!auth) {
      console.error("Firebase Auth n'est pas initialis√©. V√©rifiez la configuration.");
      setAuthState(s => ({ ...s, isLoading: false }));
      return;
    }

    // Tente de se connecter avec le jeton fourni ou anonymement
    const authenticate = async () => {
      try {
        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
          await signInWithCustomToken(auth, __initial_auth_token);
        } else {
          await signInAnonymously(auth);
        }
      } catch (error) {
        console.error("Erreur d'authentification Firebase:", error);
      }
    };

    const unsubscribe = onAuthStateChanged(auth, (user) => {
      if (user) {
        setAuthState({ userId: user.uid, isLoading: false, db, auth });
      } else {
        authenticate(); // Si pas encore authentifi√©, lance l'authentification
      }
    });

    return () => unsubscribe();
  }, []);

  const userId = authState.userId;
  const isReady = !authState.isLoading && userId;

  // 2. Gestion des donn√©es Firestore (Profil, Disponibilit√©, Matchs)
  useEffect(() => {
    if (!isReady) return;

    // A. √âcouter les changements du profil utilisateur
    const profileRef = doc(getPublicCollectionRef('user_profiles'), userId);
    const unsubProfile = onSnapshot(profileRef, (docSnap) => {
      if (docSnap.exists()) {
        const data = docSnap.data();
        setUserProfile(data);
        setUserName(data.name || '');
        setUserCity(data.city || '');
      } else {
        // Le profil n'existe pas, il faut le cr√©er
        setUserProfile({ name: '', city: '', dogProfileLabel: '', dogProfileColor: '' });
      }
    }, (error) => console.error("Erreur de snapshot de profil:", error));

    // B. √âcouter les changements de disponibilit√©
    const availRef = doc(getPublicCollectionRef('availabilities'), userId);
    const unsubAvail = onSnapshot(availRef, (docSnap) => {
      if (docSnap.exists()) {
        setAvailabilities(docSnap.data().slots || {});
      } else {
        // Initialiser la disponibilit√© vide
        const initialSlots = {};
        DAYS.forEach(day => initialSlots[day] = SLOTS.reduce((acc, slot) => ({ ...acc, [slot]: false }), {}));
        setAvailabilities(initialSlots);
      }
    }, (error) => console.error("Erreur de snapshot de disponibilit√©:", error));

    // C. √âcouter les changements des matchs (tous les matchs)
    const qMatches = query(getPublicCollectionRef('matches'));
    const unsubMatches = onSnapshot(qMatches, (snapshot) => {
      const allMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      // Filtrer pour ne montrer que les matchs de l'utilisateur actuel
      const myMatches = allMatches.filter(match => match.members.some(m => m.userId === userId));
      setMatches(myMatches.sort((a, b) => new Date(a.date) - new Date(b.date)));
    }, (error) => console.error("Erreur de snapshot de matchs:", error));


    return () => {
      unsubProfile();
      unsubAvail();
      unsubMatches();
    };
  }, [isReady]);


  // Fonction de sauvegarde du profil
  const handleSaveProfile = async () => {
    if (!userName || !userCity) {
      setStatusMessage({ type: 'error', text: 'Le nom et la ville sont obligatoires.' });
      return;
    }

    if (!userProfile.dogProfileLabel) {
      setStatusMessage({ type: 'error', text: 'Vous devez attendre que l\'administrateur vous attribue un profil de chien.' });
      return;
    }

    const profileData = {
      ...userProfile,
      name: userName,
      city: userCity,
      lastUpdate: serverTimestamp(),
    };

    try {
      await setDoc(doc(getPublicCollectionRef('user_profiles'), userId), profileData, { merge: true });
      setIsEditingProfile(false);
      setStatusMessage({ type: 'success', text: 'Profil mis √† jour avec succ√®s.' });
    } catch (e) {
      console.error("Erreur lors de la mise √† jour du profil: ", e);
      setStatusMessage({ type: 'error', text: 'Erreur lors de la sauvegarde du profil.' });
    }
  };

  // Fonction de mise √† jour des disponibilit√©s
  const handleSlotToggle = useCallback(async (day, slot) => {
    if (!isReady) return;

    const newAvailabilities = {
      ...availabilities,
      [day]: {
        ...(availabilities[day] || {}),
        [slot]: !(availabilities[day]?.[slot] || false),
      }
    };
    setAvailabilities(newAvailabilities);

    try {
      const availRef = doc(getPublicCollectionRef('availabilities'), userId);
      await setDoc(availRef, { userId, slots: newAvailabilities }, { merge: true });
      setStatusMessage({ type: 'success', text: 'Disponibilit√© mise √† jour.' });
    } catch (e) {
      console.error("Erreur lors de la mise √† jour des disponibilit√©s: ", e);
      setStatusMessage({ type: 'error', text: 'Erreur lors de la sauvegarde des disponibilit√©s.' });
    }
  }, [isReady, userId, availabilities]);

  // Fonction d'envoi de message dans un match
  const handleSendMessage = async (matchId, messageText) => {
    if (!messageText.trim()) return;

    try {
      const matchRef = doc(getPublicCollectionRef('matches'), matchId);
      const message = {
        senderId: userId,
        senderName: userProfile.name,
        text: messageText,
        timestamp: serverTimestamp(),
      };
      await updateDoc(matchRef, {
        messages: arrayUnion(message)
      });
      // Le chat sera mis √† jour automatiquement via onSnapshot
    } catch (e) {
      console.error("Erreur lors de l'envoi du message: ", e);
      setStatusMessage({ type: 'error', text: 'Erreur lors de l\'envoi du message.' });
    }
  };

  // --- LOGIQUE ADMIN SIMPLIFI√âE (Fonction de Matching) ---
  // NOTE: Dans une vraie application, cette logique devrait √™tre dans une Cloud Function pour √™tre s√©curis√©e.

  const ADMIN_DOG_PROFILES = Object.keys(DOG_PROFILES);

  // Fonction pour l'Admin: Attribuer un profil √† un utilisateur (pour la d√©mo)
  const assignRandomProfile = async () => {
    if (!isReady) return;

    // S√©lectionne un profil al√©atoire pour l'Admin / D√©mo
    const randomLabel = ADMIN_DOG_PROFILES[Math.floor(Math.random() * ADMIN_DOG_PROFILES.length)];
    const profile = DOG_PROFILES[randomLabel];

    const profileData = {
      name: userName || 'Utilisateur Test',
      city: userCity || 'Niort',
      dogProfileLabel: randomLabel, // L'√©tiquette cach√©e (Admin)
      dogProfileColor: profile.emoji, // La couleur visible (Client)
      lastUpdate: serverTimestamp(),
    };

    try {
      await setDoc(doc(getPublicCollectionRef('user_profiles'), userId), profileData, { merge: true });
      setStatusMessage({ type: 'success', text: `(ADMIN) Profil "${randomLabel}" assign√© avec succ√®s.` });
    } catch (e) {
      console.error("Erreur lors de l'assignation du profil: ", e);
      setStatusMessage({ type: 'error', text: "Erreur lors de l'assignation du profil." });
    }
  };

  // Fonction pour v√©rifier la compatibilit√©
  const areDogsCompatible = (profile1, profile2) => {
    // Un polyvalent est toujours compatible avec tout le monde
    if (profile1 === 'Polyvalent' || profile2 === 'Polyvalent') return true;

    // V√©rifie si le Profil 1 est compatible avec le Profil 2
    const p1Compat = DOG_PROFILES[profile1]?.compatibleWith.includes(profile2);
    // V√©rifie si le Profil 2 est compatible avec le Profil 1 (la compatibilit√© doit √™tre mutuelle)
    const p2Compat = DOG_PROFILES[profile2]?.compatibleWith.includes(profile1);

    return p1Compat && p2Compat;
  };

  // Algorithme de Matching (SIMULATION ADMIN)
  const runMatchingLogic = async () => {
    if (!isReady) {
      setStatusMessage({ type: 'error', text: 'Authentification en cours...' });
      return;
    }

    setStatusMessage({ type: 'info', text: 'Lancement de l\'algorithme de matching...' });

    // 1. R√©cup√©rer tous les profils et toutes les disponibilit√©s
    const [profilesSnapshot, availabilitiesSnapshot] = await Promise.all([
      getDocs(getPublicCollectionRef('user_profiles')),
      getDocs(getPublicCollectionRef('availabilities'))
    ]);

    const allProfiles = profilesSnapshot.docs.map(doc => ({ userId: doc.id, ...doc.data() }));
    const allAvailabilities = availabilitiesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    const usersData = allProfiles.filter(p => p.dogProfileLabel).reduce((acc, profile) => {
      const availability = allAvailabilities.find(a => a.userId === profile.userId);
      if (availability) {
        acc[profile.userId] = { ...profile, slots: availability.slots };
      }
      return acc;
    }, {});

    const users = Object.values(usersData);
    if (users.length < 2) {
      setStatusMessage({ type: 'info', text: 'Moins de deux utilisateurs disponibles pour un match.' });
      return;
    }

    let successfulMatches = [];

    // 2. Parcourir chaque jour et chaque cr√©neau
    DAYS.forEach(day => {
      SLOTS.forEach(slot => {
        const timeSlotKey = `${day} - ${slot}`;

        // Filtrer les utilisateurs disponibles pour ce cr√©neau
        let availableUsers = users.filter(u => u.slots?.[day]?.[slot]);

        // R√®gle: Chaque chien ne fait qu‚Äôune balade par jour
        // Pour simplifier ici, on garantit qu'il n'y ait qu'un seul match par cr√©neau. 
        // Le filtre 'matchedUserIds' ci-dessous aide √† √©viter les doublons au sein d'un m√™me cr√©neau/jour.
        
        if (availableUsers.length < 2) return; // Pas assez de monde pour matcher

        // 3. Tenter de cr√©er un ou plusieurs groupes pour ce cr√©neau
        let matchedUserIds = new Set();
        let groups = [];

        // Simple it√©ration gloutonne pour former les groupes
        availableUsers.forEach(userA => {
          if (matchedUserIds.has(userA.userId)) return;

          let currentGroup = [userA];
          matchedUserIds.add(userA.userId);

          // Chercher les autres membres compatibles
          availableUsers.forEach(userB => {
            if (userA.userId === userB.userId || matchedUserIds.has(userB.userId)) return;

            // V√©rifier la compatibilit√© de UserB avec TOUS les membres actuels du groupe
            const isCompatibleWithGroup = currentGroup.every(existingMember =>
              areDogsCompatible(existingMember.dogProfileLabel, userB.dogProfileLabel)
            );

            if (isCompatibleWithGroup) {
              currentGroup.push(userB);
              matchedUserIds.add(userB.userId);
            }
          });

          // Si le groupe a au moins 2 membres, le valider
          if (currentGroup.length >= 2) {
            groups.push(currentGroup);
          } else {
            // Si un utilisateur ne peut pas √™tre group√©, on le d√©-match 
            matchedUserIds.delete(userA.userId);
          }
        });

        // 4. Finaliser et sauvegarder les matchs
        groups.forEach(group => {
          // D√©terminer le lieu recommand√© (le plus fr√©quent ou Niort)
          const cityCounts = group.reduce((acc, m) => {
            acc[m.city] = (acc[m.city] || 0) + 1;
            return acc;
          }, {});

          let recommendedCity = 'Niort';
          let maxCount = 0;
          
          // Trouver la ville la plus fr√©quente
          for (const [city, count] of Object.entries(cityCounts)) {
            if (count > maxCount) {
              maxCount = count;
              recommendedCity = city;
            } else if (count === maxCount && city === 'Niort') {
               // R√®gle 3: S'il y a √©galit√©, Niort par d√©faut
               recommendedCity = 'Niort';
            }
          }
          
          const matchData = {
            timeSlot: slot,
            date: day,
            members: group.map(m => ({ userId: m.userId, name: m.name, color: m.dogProfileColor })),
            location: recommendedCity,
            messages: [],
            createdAt: serverTimestamp(),
          };

          const matchId = `${day}-${slot}-${Math.random().toString(36).substring(2, 9)}`;
          successfulMatches.push(setDoc(doc(getPublicCollectionRef('matches'), matchId), matchData));
        });
      });
    });

    try {
      await Promise.all(successfulMatches);
      setStatusMessage({ type: 'success', text: `Matching termin√©! ${successfulMatches.length} groupe(s) cr√©√©(s).` });
    } catch (e) {
      console.error("Erreur lors de la sauvegarde des matchs: ", e);
      setStatusMessage({ type: 'error', text: 'Erreur lors de la sauvegarde des matchs.' });
    }
  };
  
  // --- Composants d'interface utilisateur (UI) ---

  const NavButton = ({ tab, label, icon }) => (
    <button
      onClick={() => setActiveTab(tab)}
      className={`flex-1 p-3 text-center transition-colors duration-200 rounded-lg ${activeTab === tab
        ? 'bg-indigo-600 text-white shadow-lg'
        : 'bg-white text-gray-700 hover:bg-indigo-50'
        }`}
    >
      <span className="text-xl">{icon}</span>
      <span className="block text-xs font-semibold mt-1">{label}</span>
    </button>
  );

  const StatusDisplay = ({ message }) => {
    if (!message.text) return null;
    let baseStyle = "p-3 rounded-lg text-sm mb-4 font-medium";
    if (message.type === 'success') {
      baseStyle += " bg-green-100 text-green-700 border border-green-300";
    } else if (message.type === 'error') {
      baseStyle += " bg-red-100 text-red-700 border border-red-300";
    } else {
      baseStyle += " bg-blue-100 text-blue-700 border border-blue-300";
    }

    return (
      <div className={baseStyle}>
        {message.text}
      </div>
    );
  };
  
  // --- Page 1: Disponibilit√©s ---
  const PageDisponibilites = () => (
    <div>
      <h2 className="text-2xl font-bold mb-4 text-gray-800">üìç Mes Disponibilit√©s</h2>
      <p className="mb-6 text-gray-600">S√©lectionnez les cr√©neaux o√π vous souhaitez faire une balade.</p>
      
      {isReady && userProfile && !userProfile.dogProfileLabel && (
        <div className="bg-red-50 border border-red-200 p-4 rounded-xl mb-6 shadow-sm">
          <p className="font-semibold text-red-700">üîí Profil Non Attribu√©</p>
          <p className="text-sm text-red-600">Vous devez attendre que l'administrateur vous attribue un profil de chien avant que le matching ne puisse avoir lieu.</p>
        </div>
      )}

      <div className="overflow-x-auto">
        <table className="min-w-full bg-white shadow-xl rounded-xl">
          <thead>
            <tr className="bg-gray-100 text-gray-600 text-sm leading-normal">
              <th className="py-3 px-2 text-left font-semibold">Cr√©neau</th>
              {DAYS.map(day => (
                <th key={day} className="py-3 px-2 text-center font-semibold">{day}</th>
              ))}
            </tr>
          </thead>
          <tbody className="text-gray-600 text-sm font-light">
            {SLOTS.map(slot => (
              <tr key={slot} className="border-b border-gray-200 hover:bg-gray-50">
                <td className="py-3 px-2 font-medium bg-gray-50 sticky left-0">{slot}</td>
                {DAYS.map(day => {
                  const isAvailable = availabilities[day]?.[slot] || false;
                  return (
                    <td key={`${day}-${slot}`} className="py-2 px-2 text-center">
                      <button
                        onClick={() => handleSlotToggle(day, slot)}
                        className={`w-8 h-8 rounded-full transition-all duration-150 ease-in-out flex items-center justify-center border-2 shadow-inner 
                          ${isAvailable
                            ? 'bg-indigo-500 border-indigo-600 text-white transform scale-110'
                            : 'bg-gray-200 border-gray-300 text-gray-600 hover:bg-indigo-100'
                          }`}
                        aria-label={`Toggle availability for ${day} ${slot}`}
                      >
                        {isAvailable ? '‚úî' : ' '}
                      </button>
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <h3 className="text-xl font-bold mt-8 mb-4 text-gray-800">‚öôÔ∏è Outils de D√©mo Admin</h3>
      <p className="text-sm text-gray-600 mb-4">Ces boutons simulent les actions que l'administrateur Black Dog Balades ferait c√¥t√© serveur.</p>
      <div className="flex gap-4">
        <button
          onClick={assignRandomProfile}
          className="flex-1 bg-teal-500 hover:bg-teal-600 text-white font-semibold py-3 px-4 rounded-xl transition shadow-md"
          disabled={!isReady}
        >
          {userProfile?.dogProfileLabel ? `R√©-assigner Profil (${userProfile.dogProfileLabel})` : 'Assigner Profil Chien (Admin Simul√©)'}
        </button>
        <button
          onClick={runMatchingLogic}
          className="flex-1 bg-amber-500 hover:bg-amber-600 text-white font-semibold py-3 px-4 rounded-xl transition shadow-md"
          disabled={!isReady}
        >
          Lancer le Matching (Admin Simul√©)
        </button>
      </div>
    </div>
  );

  // --- Page 2: Profil ---
  const PageProfil = () => (
    <div>
      <h2 className="text-2xl font-bold mb-4 text-gray-800">üêæ Mon Profil</h2>
      <p className="mb-6 text-gray-600">Votre identifiant unique : <code className="text-xs bg-gray-100 p-1 rounded break-all">{userId || 'Chargement...'}</code></p>

      {userProfile && userProfile.dogProfileLabel && (
        <div className="p-6 mb-6 bg-white border-4 border-gray-100 rounded-2xl shadow-xl flex items-center justify-between">
          <div>
            <p className="text-lg font-semibold text-gray-700">Couleur de Profil :</p>
            <p className="text-3xl mt-1">{userProfile.dogProfileColor} {userProfile.dogProfileColor} {userProfile.dogProfileColor}</p>
          </div>
          <div className="text-right">
            <p className="text-xs text-gray-500">Profil attribu√© par l'Admin</p>
            <p className="text-sm font-bold text-indigo-600">
              {/* L'√©tiquette est techniquement dans le code, mais n'est pas affich√©e au client.
                  Nous l'affichons ici pour la d√©mo, mais en production, cela serait masqu√©. */}
              {isReady && userProfile.dogProfileLabel ? `(D√âMO: ${userProfile.dogProfileLabel})` : 'En attente'}
            </p>
          </div>
        </div>
      )}

      <div className="bg-white p-6 rounded-2xl shadow-xl">
        <div className="mb-4">
          <label className="block text-gray-700 font-semibold mb-2">Nom / Pr√©nom</label>
          <input
            type="text"
            value={userName}
            onChange={(e) => setUserName(e.target.value)}
            disabled={!isEditingProfile}
            className={`w-full p-3 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500 ${isEditingProfile ? 'bg-white' : 'bg-gray-100'}`}
          />
        </div>
        <div className="mb-6">
          <label className="block text-gray-700 font-semibold mb-2">Ville de R√©sidence</label>
          <input
            type="text"
            value={userCity}
            onChange={(e) => setUserCity(e.target.value)}
            disabled={!isEditingProfile}
            className={`w-full p-3 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500 ${isEditingProfile ? 'bg-white' : 'bg-gray-100'}`}
          />
        </div>

        {isEditingProfile ? (
          <button
            onClick={handleSaveProfile}
            className="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-3 rounded-xl transition shadow-md"
          >
            Sauvegarder le Profil
          </button>
        ) : (
          <button
            onClick={() => setIsEditingProfile(true)}
            className="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-3 rounded-xl transition shadow-md"
          >
            Modifier
          </button>
        )}
      </div>
    </div>
  );

  // --- Page 3: Groupes ---
  const PageGroupes = () => (
    <div>
      <h2 className="text-2xl font-bold mb-6 text-gray-800">üí¨ Mes Groupes de Balades</h2>

      {matches.length === 0 ? (
        <div className="p-8 bg-white rounded-2xl shadow-xl text-center">
          <p className="text-6xl mb-4">üò¥</p>
          <p className="text-lg font-semibold text-gray-700">Pas de balades pr√©vues pour le moment.</p>
          <p className="text-sm text-gray-500 mt-2">V√©rifiez vos disponibilit√©s et lancez le matching (Admin Simul√©) sur la page Disponibilit√©s.</p>
        </div>
      ) : (
        matches.map(match => <MatchCard key={match.id} match={match} onSendMessage={handleSendMessage} currentUserId={userId} />)
      )}
    </div>
  );

  // Composant pour une carte de Match
  const MatchCard = ({ match, onSendMessage, currentUserId }) => {
    const [messageInput, setMessageInput] = useState('');
    const { date, timeSlot, location, members, messages = [] } = match;

    const memberList = members.map(m => m.color + ' ' + m.name).join(', ');

    const handleSend = () => {
      onSendMessage(match.id, messageInput);
      setMessageInput('');
    };

    return (
      <div className="bg-white p-6 rounded-2xl shadow-xl mb-6 border border-indigo-200">
        <div className="mb-4 flex justify-between items-start">
          <div>
            <h3 className="text-xl font-bold text-indigo-700">Balade : {date} ({timeSlot})</h3>
            <p className="text-sm text-gray-600 mt-1">Lieu recommand√© : <span className="font-semibold text-indigo-600">{location}</span></p>
          </div>
          <div className="bg-indigo-100 text-indigo-600 text-xs font-bold py-1 px-3 rounded-full shadow-inner">
            {members.length} Chiens
          </div>
        </div>

        <p className="text-sm mb-4 border-t pt-3">
          <span className="font-semibold">Membres :</span> {memberList}
        </p>

        {/* Espace Discussion */}
        <div className="h-48 overflow-y-auto bg-gray-50 p-3 rounded-lg border mb-4">
          {messages.length === 0 ? (
            <p className="text-center text-gray-400 text-sm italic">D√©marrez la conversation...</p>
          ) : (
            messages.map((msg, index) => (
              <div key={index} className={`mb-2 ${msg.senderId === currentUserId ? 'text-right' : 'text-left'}`}>
                <span
                  className={`inline-block p-2 rounded-xl text-sm max-w-[80%] shadow-sm ${msg.senderId === currentUserId ? 'bg-indigo-500 text-white rounded-br-none' : 'bg-gray-200 text-gray-800 rounded-tl-none'}`}
                >
                  {msg.senderId !== currentUserId && <span className="block font-semibold text-xs mb-1 opacity-80">{msg.senderName}</span>}
                  {msg.text}
                </span>
              </div>
            ))
          )}
        </div>

        {/* Zone d'envoi de message */}
        <div className="flex gap-2">
          <input
            type="text"
            value={messageInput}
            onChange={(e) => setMessageInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSend()}
            placeholder="√âcrire un message..."
            className="flex-1 p-3 border border-gray-300 rounded-xl focus:ring-indigo-500 focus:border-indigo-500"
          />
          <button
            onClick={handleSend}
            className="bg-indigo-500 hover:bg-indigo-600 text-white p-3 rounded-xl font-bold transition shadow-md"
            disabled={!messageInput.trim()}
          >
            Envoyer
          </button>
        </div>
      </div>
    );
  };


  // --- RENDU GLOBAL ---
  if (!isReady) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 p-4">
        <div className="text-center p-6 bg-white rounded-xl shadow-2xl">
          <svg className="animate-spin h-8 w-8 text-indigo-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
          <p className="mt-4 text-gray-700">Connexion √† Firebase en cours...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 font-sans p-4 sm:p-6">
      <div className="max-w-4xl mx-auto">
        
        <h1 className="text-3xl font-extrabold text-gray-900 mb-6">
          <span className="text-indigo-600">üêæ Black Dog Balades</span>
        </h1>

        <div className="sticky top-0 z-10 bg-gray-50 pt-1 pb-4">
          <div className="flex justify-around bg-white p-2 rounded-2xl shadow-xl space-x-2">
            <NavButton tab="profil" label="Mon Profil" icon="üë§" />
            <NavButton tab="disponibilites" label="Disponibilit√©s" icon="üìÖ" />
            <NavButton tab="groupes" label="Groupes & Chat" icon="üí¨" />
          </div>
        </div>

        <div className="mt-6">
          <StatusDisplay message={statusMessage} />
          {activeTab === 'profil' && <PageProfil />}
          {activeTab === 'disponibilites' && <PageDisponibilites />}
          {activeTab === 'groupes' && <PageGroupes />}
        </div>

      </div>
    </div>
  );
}
// Render the application
const rootElement = document.getElementById('root');
const root = ReactDOM.createRoot(rootElement);
root.render(<App />);
