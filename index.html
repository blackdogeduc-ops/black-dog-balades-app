<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Dog Balades</title>
    <!-- Chargement de Tailwind CSS pour le style -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Utilisation de la police Inter -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            margin: 0;
        }
        .overflow-x-auto {
            overflow-x: auto;
        }
        .sticky-col {
            position: sticky;
            left: 0;
            z-index: 10; 
        }
        .sticky-col-body {
            background-color: #ffffff; 
        }
        /* Style pour masquer le contenu React tant que l'initialisation n'est pas termin√©e */
        #root:empty::before {
            content: "Chargement en cours...";
            display: block;
            text-align: center;
            padding: 50px;
            color: #4f46e5;
            font-size: 1.25rem;
        }
    </style>

    <!-- 1. CHARGEMENT DES LIBRAIRIES REACT ET BABEL -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 2. CHARGEMENT ET INITIALISATION DE FIREBASE (MUST BE TYPE="MODULE") -->
    <script type="module">
        // Importations des modules Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, query, onSnapshot, updateDoc, arrayUnion, serverTimestamp, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // *******************************************************************
        // !!! CONFIGURATION FIREBASE !!!
        // *******************************************************************
        const firebaseConfig = {
          apiKey: "AIzaSyCZRKtoBY4LKH2_aqfOlUIEgSlLBxZknCg", 
          authDomain: "black-dog-balades.firebaseapp.com",
          projectId: "black-dog-balades", 
          storageBucket: "black-dog-balades.firebasestorage.app",
          messagingSenderId: "225366459890",
          appId: "1:225366459890:web:f6c13a345b4e5b95b4976b"
        };
        const APP_ID = firebaseConfig.projectId || 'black-dog-balades-live';
        // *******************************************************************

        // Initialisation des instances
        let app, db, auth;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
        } catch (e) {
            console.error("Erreur lors de l'initialisation de Firebase.", e);
        }
        
        // EXPOSER TOUT CE QUI EST N√âCESSAIRE AU BLOC JSX
        window.firebaseDependencies = {
            // Fonctions Firestore
            getFirestore, doc, setDoc, collection, query, onSnapshot, updateDoc, arrayUnion, serverTimestamp, getDocs,
            // Fonctions Auth
            getAuth, signInAnonymously, onAuthStateChanged,
            // Instances initialis√©es et ID
            dbInstance: db,
            authInstance: auth,
            appId: APP_ID
        };

        // Optionnel : Lancer un √©v√©nement pour signaler que les d√©pendances sont pr√™tes
        window.dispatchEvent(new CustomEvent('firebase-ready'));
    </script>
</head>
<body>
    <div id="root"></div>

    <!-- 3. CODE REACT/JSX (S'ex√©cute apr√®s le module Firebase) -->
    <script type="text/babel">
        // Import des hooks et composants React
        const { useState, useEffect, useCallback, useMemo, useRef } = React;
        
        // √âtat initial pour les d√©pendances Firebase
        const initialDependencies = {
            dbInstance: null,
            authInstance: null,
            appId: 'loading',
            // Remplir avec les fonctions n√©cessaires pour √©viter les erreurs d'appel
            getFirestore: () => console.error('DB not ready'),
            getAuth: () => console.error('Auth not ready'),
            // ... autres fonctions ...
            doc: () => {}, setDoc: () => {}, collection: () => {}, query: () => {}, onSnapshot: () => {}, 
            updateDoc: () => {}, arrayUnion: () => {}, serverTimestamp: () => {}, getDocs: () => {}, 
            signInAnonymously: () => {}, onAuthStateChanged: () => {},
        };

        const App = () => {
          // Utiliser un √©tat pour stocker les d√©pendances une fois qu'elles sont charg√©es
          const [firebaseDeps, setFirebaseDeps] = useState(initialDependencies);
          const [isFirebaseLoaded, setIsFirebaseLoaded] = useState(false);

          // R√©cup√©ration des d√©pendances du module apr√®s l'√©v√©nement 'firebase-ready'
          useEffect(() => {
            const loadDeps = () => {
              if (window.firebaseDependencies) {
                setFirebaseDeps(window.firebaseDependencies);
                setIsFirebaseLoaded(true);
              }
            };
            
            // Si les d√©pendances sont d√©j√† l√†, charger imm√©diatement (cas o√π le script JSX est lent)
            if (window.firebaseDependencies) {
                loadDeps();
            } else {
                // Attendre l'√©v√©nement (cas le plus probable)
                window.addEventListener('firebase-ready', loadDeps);
            }
            return () => window.removeEventListener('firebase-ready', loadDeps);
          }, []);

          // Destruction des d√©pendances pour React
          const { 
              dbInstance: db, authInstance: auth, appId,
              getFirestore, doc, setDoc, collection, query, onSnapshot, updateDoc, arrayUnion, serverTimestamp, getDocs,
              signInAnonymously, onAuthStateChanged
          } = firebaseDeps;
          
          // --- Le reste du code React commence ici ---
          
          // --- CONFIGURATION DE BASE ET PROFILES CHIENS (R√®gles M√©tier) ---
          const DOG_PROFILES = {
            Chiot: { color: 'purple', emoji: 'üü£', compatibleWith: ['Polyvalent', 'Chiot', 'Harceleur'] },
            Polyvalent: { color: 'yellow', emoji: 'üü°', compatibleWith: ['Chiot', 'Polyvalent', 'Agressif', 'Peureux', 'Harceleur'] },
            Agressif: { color: 'red', emoji: 'üî¥', compatibleWith: ['Polyvalent'] },
            Peureux: { color: 'blue', emoji: 'üîµ', compatibleWith: ['Polyvalent', 'Chiot'] },
            Harceleur: { color: 'orange', emoji: 'üü†', compatibleWith: ['Polyvalent', 'Harceleur', 'Chiot'] },
          };
          const DAYS = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
          const SLOTS = ['Matin', 'D√©but AP', 'Fin AP', 'Soir√©e'];
          const ADMIN_DOG_PROFILES = Object.keys(DOG_PROFILES);

          // --- √âtats React ---
          const [activeTab, setActiveTab] = useState('profil');
          const [authState, setAuthState] = useState({ userId: null, isLoading: true, error: null });
          const [userName, setUserName] = useState('');
          const [userCity, setUserCity] = useState('');
          const [isEditingProfile, setIsEditingProfile] = useState(false);
          const [userProfile, setUserProfile] = useState(null); 
          const [availabilities, setAvailabilities] = useState({});
          const [matches, setMatches] = useState([]);
          const [statusMessage, setStatusMessage] = useState({ type: '', text: '' }); 
          const autoMatchExecuted = useRef(false);

          // --- Fonctions Utils ---
          const updateStatus = (type, text) => {
            setStatusMessage({ type, text });
            setTimeout(() => setStatusMessage({ type: '', text: '' }), 4000);
          };

          const getPublicCollectionRef = (collectionName) => {
            if (!db) return null;
            return collection(db, `/artifacts/${appId}/public/data/${collectionName}`);
          };
          
          const areDogsCompatible = (profile1, profile2) => {
            const p1Profile = DOG_PROFILES[profile1];
            if (!p1Profile || !p1Profile.compatibleWith.includes(profile2)) {
                return false;
            }
            const p2Profile = DOG_PROFILES[profile2];
            if (!p2Profile || !p2Profile.compatibleWith.includes(profile1)) {
                return false;
            }
            return true;
          };

          // 1. Initialisation de l'Auth
          useEffect(() => {
            if (!isFirebaseLoaded || !auth) return;

            const authenticate = async () => {
              try {
                if (!auth.currentUser) {
                    await signInAnonymously(auth);
                }
              } catch (error) {
                console.error("Erreur d'authentification Firebase:", error);
                setAuthState(s => ({ ...s, isLoading: false, error: '√âchec de la connexion Firebase.' }));
                updateStatus('error', 'Erreur de connexion √† la base de donn√©es. V√©rifiez votre configuration Firebase.');
              }
            };

            const unsubscribe = onAuthStateChanged(auth, (user) => {
              if (user) {
                setAuthState({ userId: user.uid, isLoading: false, error: null });
              } else if (!authState.error) {
                authenticate(); 
              }
            });

            return () => unsubscribe();
          }, [isFirebaseLoaded]); // D√©pend de l'√©tat de chargement de Firebase

          const userId = authState.userId;
          const isReady = isFirebaseLoaded && !authState.isLoading && userId;
          
          // 2. Gestion des donn√©es Firestore (Profil, Disponibilit√©, Matchs)
          useEffect(() => {
            if (!isReady || authState.error || !db) return;

            const profileRef = doc(getPublicCollectionRef('user_profiles'), userId);
            const availRef = doc(getPublicCollectionRef('availabilities'), userId);
            const qMatches = query(getPublicCollectionRef('matches'));

            const unsubProfile = onSnapshot(profileRef, (docSnap) => {
              if (docSnap.exists()) {
                const data = docSnap.data();
                setUserProfile(data);
                setUserName(data.name || '');
                setUserCity(data.city || '');
              } else {
                setUserProfile({ name: '', city: '', dogProfileLabel: '', dogProfileColor: '' });
              }
            }, (error) => console.error("Erreur de snapshot de profil:", error));

            const unsubAvail = onSnapshot(availRef, (docSnap) => {
              if (docSnap.exists()) {
                setAvailabilities(docSnap.data().slots || {});
              } else {
                const initialSlots = {};
                DAYS.forEach(day => initialSlots[day] = SLOTS.reduce((acc, slot) => ({ ...acc, [slot]: false }), {}));
                setAvailabilities(initialSlots);
              }
            }, (error) => console.error("Erreur de snapshot de disponibilit√©:", error));

            const unsubMatches = onSnapshot(qMatches, (snapshot) => {
              const allMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
              const myMatches = allMatches.filter(match => match.members.some(m => m.userId === userId));
              setMatches(myMatches.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0)));
            }, (error) => console.error("Erreur de snapshot de matchs:", error));


            return () => {
              unsubProfile();
              unsubAvail();
              unsubMatches();
            };
          }, [isReady, authState.error, db]);

          // 3. Logique d'auto-initialisation forc√©e (pour garantir un match en d√©mo)
          useEffect(() => {
            if (!isReady || autoMatchExecuted.current || authState.error || !db) return;
            
            const profileExists = userProfile && userProfile.dogProfileLabel && userProfile.name && userProfile.city;

            if (!profileExists && userProfile && Object.keys(userProfile).length > 0) {
                const setupAndMatch = async () => {
                    updateStatus('info', 'Configuration de d√©mo forc√©e en cours (assignation profil + dispo + matching)...');
                    autoMatchExecuted.current = true;

                    const label = 'Polyvalent';
                    const profile = DOG_PROFILES[label];
                    const profileData = {
                      name: userName || 'Utilisateur Demo', 
                      city: userCity || 'Niort', 
                      dogProfileLabel: label, 
                      dogProfileColor: profile.emoji, 
                      lastUpdate: serverTimestamp(),
                    };
                    await setDoc(doc(getPublicCollectionRef('user_profiles'), userId), profileData, { merge: true });

                    const allSlots = {};
                    DAYS.forEach(day => allSlots[day] = SLOTS.reduce((acc, slot) => ({ ...acc, [slot]: true }), {}));
                    const availRef = doc(getPublicCollectionRef('availabilities'), userId);
                    await setDoc(availRef, { userId, slots: allSlots }, { merge: true });
                    
                    setTimeout(async () => {
                        await runMatchingLogic();
                        setActiveTab('groupes'); 
                    }, 1500);
                };
                
                setupAndMatch();
            }
          }, [isReady, userProfile, authState.error, db]);


          // Fonction de sauvegarde du profil
          const handleSaveProfile = async () => {
            if (!isReady) {
                updateStatus('error', 'Connexion en cours, veuillez patienter.');
                return;
            }
            if (!userName || !userCity) {
              updateStatus('error', 'Le nom et la ville sont obligatoires.');
              return;
            }

            if (!userProfile.dogProfileLabel) {
              updateStatus('error', 'Veuillez d\'abord vous attribuer un profil de chien (Admin Simul√©).');
              return;
            }

            const profileData = {
              ...userProfile,
              name: userName,
              city: userCity,
              lastUpdate: serverTimestamp(),
            };

            try {
              await setDoc(doc(getPublicCollectionRef('user_profiles'), userId), profileData, { merge: true });
              setIsEditingProfile(false);
              updateStatus('success', 'Profil mis √† jour avec succ√®s.');
            } catch (e) {
              console.error("Erreur lors de la mise √† jour du profil: ", e);
              updateStatus('error', 'Erreur lors de la sauvegarde du profil.');
            }
          };

          // Fonction de mise √† jour des disponibilit√©s
          const handleSlotToggle = useCallback(async (day, slot) => {
            if (!isReady) return;

            const newAvailabilities = {
              ...availabilities,
              [day]: {
                ...(availabilities[day] || {}),
                [slot]: !(availabilities[day]?.[slot] || false),
              }
            };
            setAvailabilities(newAvailabilities);

            try {
              const availRef = doc(getPublicCollectionRef('availabilities'), userId);
              await setDoc(availRef, { userId, slots: newAvailabilities }, { merge: true });
            } catch (e) {
              console.error("Erreur lors de la mise √† jour des disponibilit√©s: ", e);
              updateStatus('error', 'Erreur lors de la sauvegarde des disponibilit√©s.');
            }
          }, [isReady, userId, availabilities]);

          // Fonction d'envoi de message dans un match
          const handleSendMessage = async (matchId, messageText) => {
            if (!isReady || authState.error || !db) return;
            if (!messageText.trim() || !userProfile || !userProfile.name) return;

            try {
              const matchRef = doc(getPublicCollectionRef('matches'), matchId);
              const message = {
                senderId: userId,
                senderName: userProfile.name,
                text: messageText,
                timestamp: serverTimestamp(), 
              };
              await updateDoc(matchRef, {
                messages: arrayUnion(message)
              });
              // Pas de r√©initialisation ici, car g√©r√©e par le composant enfant MatchCard
            } catch (e) {
              console.error("Erreur lors de l'envoi du message: ", e);
              updateStatus('error', 'Erreur lors de l\'envoi du message.');
            }
          };

          // Fonction pour l'Admin: Attribuer un profil √† un utilisateur (pour la d√©mo)
          const assignRandomProfile = async () => {
            if (!isReady || !db) {
                updateStatus('error', 'Connexion en cours, veuillez patienter.');
                return;
            }

            const randomLabel = ADMIN_DOG_PROFILES[Math.floor(Math.random() * ADMIN_DOG_PROFILES.length)];
            const profile = DOG_PROFILES[randomLabel];

            const profileData = {
              name: userName || 'Utilisateur Test',
              city: userCity || 'Niort',
              dogProfileLabel: randomLabel, 
              dogProfileColor: profile.emoji, 
              lastUpdate: serverTimestamp(),
            };

            try {
              await setDoc(doc(getPublicCollectionRef('user_profiles'), userId), profileData, { merge: true });
              updateStatus('success', `(ADMIN) Profil "${randomLabel}" assign√© avec succ√®s. Veuillez maintenant remplir votre nom et ville.`);
            } catch (e) {
              console.error("Erreur lors de l'assignation du profil: ", e);
              updateStatus('error', "Erreur lors de l'assignation du profil.");
            }
          };

          // Algorithme de Matching (SIMULATION ADMIN)
          const runMatchingLogic = async () => {
            if (!isReady || authState.error || !db) {
              updateStatus('error', 'Connexion non √©tablie ou erreur Firebase.');
              return;
            }

            updateStatus('info', 'Lancement de l\'algorithme de matching...');

            // Vider les matchs existants pour √©viter les doublons persistants en mode d√©mo
            const existingMatchesSnapshot = await getDocs(getPublicCollectionRef('matches'));
            const deletePromises = existingMatchesSnapshot.docs
                .filter(doc => doc.data().members.some(m => m.userId === userId)) // Supprimer seulement les matchs de l'utilisateur actuel
                .map(doc => deleteDoc(doc.ref));
            await Promise.all(deletePromises);


            const [profilesSnapshot, availabilitiesSnapshot] = await Promise.all([
              getDocs(getPublicCollectionRef('user_profiles')),
              getDocs(getPublicCollectionRef('availabilities'))
            ]);

            const allProfiles = profilesSnapshot.docs.map(doc => ({ userId: doc.id, ...doc.data() }));
            const allAvailabilities = availabilitiesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            const usersData = allProfiles.filter(p => p.dogProfileLabel && p.name && p.city).reduce((acc, profile) => {
              const availability = allAvailabilities.find(a => a.userId === profile.userId);
              if (availability) {
                acc[profile.userId] = { ...profile, slots: availability.slots };
              }
              return acc;
            }, {});

            const users = Object.values(usersData);
            if (users.length < 2) {
              updateStatus('info', 'Moins de deux utilisateurs (Profil + Nom/Ville + Disponibilit√©) pour un match.');
              return;
            }

            let successfulMatches = [];

            DAYS.forEach(day => {
              SLOTS.forEach(slot => {
                
                let availableUsers = users.filter(u => u.slots?.[day]?.[slot]);
                if (availableUsers.length < 2) return; 

                let matchedUserIds = new Set();
                let groups = [];

                availableUsers.forEach(userA => {
                  if (matchedUserIds.has(userA.userId)) return;

                  let currentGroup = [userA];
                  matchedUserIds.add(userA.userId);

                  availableUsers.forEach(userB => {
                    if (userA.userId === userB.userId || matchedUserIds.has(userB.userId)) return;

                    const isCompatibleWithGroup = currentGroup.every(existingMember =>
                      areDogsCompatible(existingMember.dogProfileLabel, userB.dogProfileLabel)
                    );

                    if (isCompatibleWithGroup) {
                      currentGroup.push(userB);
                      matchedUserIds.add(userB.userId);
                    }
                  });

                  if (currentGroup.length >= 2) {
                    groups.push(currentGroup);
                  } else {
                    matchedUserIds.delete(userA.userId);
                  }
                });

                groups.forEach(group => {
                  const cityCounts = group.reduce((acc, m) => {
                    acc[m.city] = (acc[m.city] || 0) + 1;
                    return acc;
                  }, {});

                  let recommendedCity = 'Niort';
                  let maxCount = 0;
                  
                  for (const [city, count] of Object.entries(cityCounts)) {
                    if (count > maxCount) {
                      maxCount = count;
                      recommendedCity = city;
                    } else if (count === maxCount && city === 'Niort') {
                       recommendedCity = city;
                    }
                  }
                  
                  const matchData = {
                    timeSlot: slot,
                    date: day,
                    members: group.map(m => ({ userId: m.userId, name: m.name, color: m.dogProfileColor })),
                    location: recommendedCity,
                    messages: [],
                    createdAt: serverTimestamp(),
                  };

                  const matchId = `${day}-${slot}-${Math.random().toString(36).substring(2, 9)}`;
                  successfulMatches.push(setDoc(doc(getPublicCollectionRef('matches'), matchId), matchData));
                });
              });
            });

            try {
              await Promise.all(successfulMatches);
              updateStatus('success', `Matching termin√©! ${successfulMatches.length} groupe(s) cr√©√©(s). Consultez l'onglet "Groupes & Chat".`);
            } catch (e) {
              console.error("Erreur lors de la sauvegarde des matchs: ", e);
              updateStatus('error', 'Erreur lors de la sauvegarde des matchs.');
            }
          };
          
          // --- Composants d'interface utilisateur (UI) ---

          const NavButton = ({ tab, label, icon }) => (
            <button
              onClick={() => setActiveTab(tab)}
              className={`flex-1 p-3 text-center transition-colors duration-200 rounded-lg ${activeTab === tab
                ? 'bg-indigo-600 text-white shadow-lg'
                : 'bg-white text-gray-700 hover:bg-indigo-50'
                }`}
            >
              <span className="text-xl">{icon}</span>
              <span className="block text-xs font-semibold mt-1">{label}</span>
            </button>
          );

          const StatusDisplay = ({ message }) => {
            if (!message.text) return null;
            let baseStyle = "p-3 rounded-lg text-sm mb-4 font-medium";
            if (message.type === 'success') {
              baseStyle += " bg-green-100 text-green-700 border border-green-300";
            } else if (message.type === 'error') {
              baseStyle += " bg-red-100 text-red-700 border border-red-300";
            } else {
              baseStyle += " bg-blue-100 text-blue-700 border border-blue-300";
            }

            return (
              <div className={baseStyle} role="alert">
                {message.text}
              </div>
            );
          };
          
          // --- Page 1: Disponibilit√©s ---
          const PageDisponibilites = () => (
            <div>
              <h2 className="text-2xl font-bold mb-4 text-gray-800">üìç Mes Disponibilit√©s</h2>
              <p className="mb-6 text-gray-600">S√©lectionnez les cr√©neaux o√π vous souhaitez faire une balade.</p>
              
              {(!isReady || (userProfile && !userProfile.dogProfileLabel)) && (
                <div className="bg-red-50 border border-red-200 p-4 rounded-xl mb-6 shadow-sm">
                  <p className="font-semibold text-red-700">üîí Profil incomplet</p>
                  <p className="text-sm text-red-600">Pour participer au matching, veuillez d'abord : 1. Vous attribuer un profil de chien (bouton Admin ci-dessous). 2. Remplir votre nom et ville sur l'onglet "Mon Profil".</p>
                </div>
              )}

              <div className="overflow-x-auto">
                <table className="min-w-full bg-white shadow-xl rounded-xl">
                  <thead>
                    <tr className="bg-gray-100 text-gray-600 text-sm leading-normal">
                      <th className="py-3 px-2 text-left font-semibold sticky-col bg-gray-100">Cr√©neau</th>
                      {DAYS.map(day => (
                        <th key={day} className="py-3 px-2 text-center font-semibold">{day}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody className="text-gray-600 text-sm font-light">
                    {SLOTS.map(slot => (
                      <tr key={slot} className="border-b border-gray-200 hover:bg-gray-50">
                        <td className="py-3 px-2 font-medium sticky-col sticky-col-body bg-white border-r border-gray-200">{slot}</td>
                        {DAYS.map(day => {
                          const isAvailable = availabilities[day]?.[slot] || false;
                          return (
                            <td key={`${day}-${slot}`} className="py-2 px-2 text-center">
                              <button
                                onClick={() => handleSlotToggle(day, slot)}
                                className={`w-10 h-10 rounded-full transition-all duration-150 ease-in-out flex items-center justify-center border-2 shadow-inner 
                                  ${isAvailable
                                    ? 'bg-indigo-500 border-indigo-600 text-white transform scale-110'
                                    : 'bg-gray-200 border-gray-300 text-gray-600 hover:bg-indigo-100'
                                  }`}
                                aria-label={`Toggle availability for ${day} ${slot}`}
                                disabled={!isReady}
                              >
                                {isAvailable ? '‚úî' : ' '}
                              </button>
                            </td>
                          );
                        })}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>

              <h3 className="text-xl font-bold mt-8 mb-4 text-gray-800">‚öôÔ∏è Outils de D√©mo Admin</h3>
              <p className="text-sm text-gray-600 mb-4">Ces boutons simulent les actions que l'administrateur Black Dog Balades ferait c√¥t√© serveur.</p>
              <div className="flex flex-col sm:flex-row gap-4">
                <button
                  onClick={assignRandomProfile}
                  className="flex-1 bg-teal-500 hover:bg-teal-600 text-white font-semibold py-3 px-4 rounded-xl transition shadow-md"
                  disabled={!isReady}
                >
                  {userProfile?.dogProfileLabel ? `R√©-assigner Profil (${userProfile.dogProfileLabel})` : '1. Assignation Profil Chien (Admin Simul√©)'}
                </button>
                <button
                  onClick={runMatchingLogic}
                  className="flex-1 bg-amber-500 hover:bg-amber-600 text-white font-semibold py-3 px-4 rounded-xl transition shadow-md"
                  disabled={!isReady}
                >
                  2. Lancer le Matching (Admin Simul√©)
                </button>
              </div>
            </div>
          );

          // --- Page 2: Profil ---
          const PageProfil = () => (
            <div>
              <h2 className="text-2xl font-bold mb-4 text-gray-800">üêæ Mon Profil</h2>
              <p className="mb-6 text-gray-600">Votre identifiant unique : <code className="text-xs bg-gray-100 p-1 rounded break-all">{userId || 'Chargement...'}</code></p>

              {userProfile && userProfile.dogProfileLabel ? (
                <div className="p-6 mb-6 bg-white border-4 border-indigo-200 rounded-2xl shadow-xl flex items-center justify-between">
                  <div>
                    <p className="text-lg font-semibold text-gray-700">Couleur de Profil :</p>
                    <p className="text-3xl mt-1">{userProfile.dogProfileColor} {userProfile.dogProfileColor} {userProfile.dogProfileColor}</p>
                  </div>
                  <div className="text-right">
                    <p className="text-xs text-gray-500">Profil attribu√© (R√®gle de compatibilit√©)</p>
                    <p className="text-sm font-bold text-indigo-600">
                      {isReady && userProfile.dogProfileLabel ? `(D√âMO: ${userProfile.dogProfileLabel})` : 'En attente'}
                    </p>
                  </div>
                </div>
              ) : (
                <div className="p-6 mb-6 bg-red-100 border border-red-300 rounded-2xl shadow-md text-red-800">
                    <p className="font-semibold">Action Requise :</p>
                    <p className="text-sm">Veuillez d'abord vous attribuer un profil de chien via le bouton **"Assignation Profil Chien (Admin Simul√©)"** dans l'onglet **Disponibilit√©s**.</p>
                </div>
              )}

              <div className="bg-white p-6 rounded-2xl shadow-xl">
                <div className="mb-4">
                  <label className="block text-gray-700 font-semibold mb-2" htmlFor="userName">Nom / Pr√©nom</label>
                  <input
                    id="userName"
                    type="text"
                    value={userName}
                    onChange={(e) => setUserName(e.target.value)}
                    disabled={!isEditingProfile}
                    className={`w-full p-3 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500 ${isEditingProfile ? 'bg-white border-gray-300' : 'bg-gray-100 border-gray-200'}`}
                    placeholder="Ex: Jean Dupont"
                  />
                </div>
                <div className="mb-6">
                  <label className="block text-gray-700 font-semibold mb-2" htmlFor="userCity">Ville de R√©sidence</label>
                  <input
                    id="userCity"
                    type="text"
                    value={userCity}
                    onChange={(e) => setUserCity(e.target.value)}
                    disabled={!isEditingProfile}
                    className={`w-full p-3 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500 ${isEditingProfile ? 'bg-white border-gray-300' : 'bg-gray-100 border-gray-200'}`}
                    placeholder="Ex: Niort ou La Rochelle"
                  />
                </div>

                {isEditingProfile ? (
                  <button
                    onClick={handleSaveProfile}
                    className="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-3 rounded-xl transition shadow-md"
                    disabled={!isReady}
                  >
                    Sauvegarder le Profil
                  </button>
                ) : (
                  <button
                    onClick={() => setIsEditingProfile(true)}
                    className="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-3 rounded-xl transition shadow-md"
                    disabled={!isReady}
                  >
                    Modifier
                  </button>
                )}
              </div>
            </div>
          );

          // --- Page 3: Groupes ---
          const PageGroupes = () => (
            <div>
              <h2 className="text-2xl font-bold mb-6 text-gray-800">üí¨ Mes Groupes de Balades</h2>

              {matches.length === 0 ? (
                <div className="p-8 bg-white rounded-2xl shadow-xl text-center">
                  <p className="text-6xl mb-4">üò¥</p>
                  <p className="text-lg font-semibold text-gray-700">Pas de balades pr√©vues pour le moment.</p>
                  <p className="text-sm text-gray-500 mt-2">1. V√©rifiez vos disponibilit√©s et votre profil. 2. Lancez le matching (Admin Simul√©) sur la page **Disponibilit√©s**.</p>
                </div>
              ) : (
                matches.map(match => <MatchCard key={match.id} match={match} onSendMessage={handleSendMessage} currentUserId={userId} />)
              )}
            </div>
          );

          // Composant pour une carte de Match
          const MatchCard = ({ match, onSendMessage, currentUserId }) => {
            const [messageInput, setMessageInput] = useState('');
            const { date, timeSlot, location, members, messages = [] } = match;

            const memberList = members.map(m => m.color + ' ' + m.name).join(', ');

            const sortedMessages = messages.sort((a, b) => {
                const timestampA = a.timestamp?.toMillis ? a.timestamp.toMillis() : (a.timestamp ? new Date(a.timestamp).getTime() : 0);
                const timestampB = b.timestamp?.toMillis ? b.timestamp.toMillis() : (b.timestamp ? new Date(b.timestamp).getTime() : 0);
                return timestampA - timestampB;
            }).filter(msg => msg.text);

            const handleSend = () => {
              if (messageInput.trim()) {
                onSendMessage(match.id, messageInput);
                setMessageInput(''); // R√©initialiser l'input ici
              }
            };
            
            const chatContainerRef = useRef(null);
            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [messages.length]);

            return (
              <div className="bg-white p-6 rounded-2xl shadow-xl mb-6 border border-indigo-200">
                <div className="mb-4 flex justify-between items-start">
                  <div>
                    <h3 className="text-xl font-bold text-indigo-700">Balade : {date} ({timeSlot})</h3>
                    <p className="text-sm text-gray-600 mt-1">Lieu recommand√© : <span className="font-semibold text-indigo-600">{location}</span></p>
                  </div>
                  <div className="bg-indigo-100 text-indigo-600 text-xs font-bold py-1 px-3 rounded-full shadow-inner">
                    {members.length} Chiens
                  </div>
                </div>

                <p className="text-sm mb-4 border-t pt-3">
                  <span className="font-semibold">Membres :</span> {memberList}
                </p>

                {/* Espace Discussion */}
                <div 
                    ref={chatContainerRef}
                    className="h-48 overflow-y-auto bg-gray-50 p-3 rounded-lg border mb-4"
                >
                  {sortedMessages.length === 0 ? (
                    <p className="text-center text-gray-400 text-sm italic">D√©marrez la conversation...</p>
                  ) : (
                    sortedMessages.map((msg, index) => (
                      <div key={index} className={`mb-2 flex ${msg.senderId === currentUserId ? 'justify-end' : 'justify-start'}`}>
                        <span
                          className={`inline-block p-3 rounded-xl text-sm max-w-[80%] shadow-md 
                            ${msg.senderId === currentUserId 
                              ? 'bg-indigo-500 text-white rounded-br-none' 
                              : 'bg-gray-200 text-gray-800 rounded-tl-none'
                            }`}
                        >
                          {msg.senderId !== currentUserId && <span className="block font-semibold text-xs mb-1 opacity-80">{msg.senderName}</span>}
                          {msg.text}
                        </span>
                      </div>
                    ))
                  )}
                </div>

                {/* Zone d'envoi de message */}
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={messageInput}
                    onChange={(e) => setMessageInput(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                    placeholder="√âcrire un message..."
                    className="flex-1 p-3 border border-gray-300 rounded-xl focus:ring-indigo-500 focus:border-indigo-500"
                  />
                  <button
                    onClick={handleSend}
                    className="bg-indigo-500 hover:bg-indigo-600 text-white p-3 rounded-xl font-bold transition shadow-md"
                    disabled={!messageInput.trim()}
                  >
                    Envoyer
                  </button>
                </div>
              </div>
            );
          };


          // --- RENDU GLOBAL ---
          if (!isFirebaseLoaded || authState.error) {
            return (
              <div className="min-h-screen flex items-center justify-center bg-gray-100 p-4">
                <div className="text-center p-6 bg-white rounded-xl shadow-2xl">
                    <svg className={`h-8 w-8 mx-auto mb-4 ${authState.error ? 'text-red-500' : 'animate-spin text-indigo-500'}`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    {authState.error ? (
                        <>
                            <p className="mt-4 text-lg font-semibold text-red-700">Erreur de Connexion √† Firebase</p>
                            <p className="mt-2 text-sm text-red-600">Veuillez v√©rifier que les 7 champs de `firebaseConfig` sont correctement remplac√©s dans le `<script type="module">` par votre configuration personnelle.</p>
                            <p className="mt-4 text-xs text-red-400">D√©tails: {authState.error}</p>
                        </>
                    ) : (
                        <p className="mt-4 text-gray-700">Connexion √† Firebase en cours...</p>
                    )}
                </div>
              </div>
            );
          }
          
          if (!isReady) {
              return (
                  <div className="min-h-screen flex items-center justify-center bg-gray-100 p-4">
                      <div className="text-center p-6 bg-white rounded-xl shadow-2xl">
                          <svg className="h-8 w-8 mx-auto mb-4 animate-spin text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                          <p className="mt-4 text-gray-700">Authentification en cours...</p>
                          <p className="mt-2 text-xs text-gray-500">UID: {userId || 'En attente'}</p>
                      </div>
                  </div>
              );
          }

          return (
            <div className="min-h-screen bg-gray-50 font-sans p-4 sm:p-6">
              <div className="max-w-4xl mx-auto">
                
                <h1 className="text-3xl font-extrabold text-gray-900 mb-6">
                  <span className="text-indigo-600">üêæ Black Dog Balades</span>
                </h1>

                <div className="sticky top-0 z-10 bg-gray-50 pt-1 pb-4">
                  <div className="flex justify-around bg-white p-2 rounded-2xl shadow-xl space-x-2">
                    <NavButton tab="profil" label="Mon Profil" icon="üë§" />
                    <NavButton tab="disponibilites" label="Disponibilit√©s" icon="üìÖ" />
                    <NavButton tab="groupes" label="Groupes & Chat" icon="üí¨" />
                  </div>
                </div>

                <div className="mt-6">
                  <StatusDisplay message={statusMessage} />
                  {activeTab === 'profil' && <PageProfil />}
                  {activeTab === 'disponibilites' && <PageDisponibilites />}
                  {activeTab === 'groupes' && <PageGroupes />}
                </div>
                
                <div className="mt-12 p-4 text-center text-xs text-gray-400 border-t pt-4">
                    <p>ID de l'Application (pour le partage des donn√©es) : {appId}</p>
                    <p>Votre ID d'utilisateur : {userId}</p>
                    <p>Version D√©mo Statique V1.1</p>
                </div>

              </div>
            </div>
          );
        }

        // Rendu final de l'application
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>
